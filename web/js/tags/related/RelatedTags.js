"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Dictionaries_1 = require("polar-shared/src/util/Dictionaries");
const Arrays_1 = require("polar-shared/src/util/Arrays");
class RelatedTags {
    constructor() {
        this.tagDocsIndex = {};
        this.docTagsIndex = {};
    }
    update(docID, mutationType, ...tags) {
        for (const tag of tags) {
            const tagMeta = Dictionaries_1.Dictionaries.computeIfAbsent(this.tagDocsIndex, tag, () => {
                return { tag, docs: new Set() };
            });
            switch (mutationType) {
                case 'set':
                    tagMeta.docs.add(docID);
                    break;
                case 'delete':
                    tagMeta.docs.delete(docID);
                    break;
            }
            const docMeta = Dictionaries_1.Dictionaries.computeIfAbsent(this.docTagsIndex, docID, () => {
                return { doc: docID, tags: [] };
            });
            docMeta.tags.push(tag);
        }
    }
    compute(tags, limit = 5) {
        const tagHits = {};
        const updateHits = (tag) => {
            const indexedTagMeta = this.tagDocsIndex[tag];
            if (!indexedTagMeta) {
                return;
            }
            const relatedDocs = indexedTagMeta.docs;
            for (const relatedDoc of relatedDocs) {
                const indexedDocMeta = this.docTagsIndex[relatedDoc];
                const relatedTags = indexedDocMeta.tags;
                for (const relatedTag of relatedTags) {
                    const tagHitMeta = Dictionaries_1.Dictionaries.computeIfAbsent(tagHits, relatedTag, () => {
                        return { tag: relatedTag, hits: 0 };
                    });
                    ++tagHitMeta.hits;
                }
            }
        };
        for (const tag of tags) {
            updateHits(tag);
        }
        const tagHitsDesc = Object.values(tagHits)
            .filter(current => !tags.includes(current.tag))
            .filter(current => current.hits > 1)
            .sort((hit0, hit1) => hit1.hits - hit0.hits);
        return Arrays_1.Arrays.head(tagHitsDesc, limit);
    }
}
exports.RelatedTags = RelatedTags;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmVsYXRlZFRhZ3MuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJSZWxhdGVkVGFncy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLHFFQUFnRTtBQUNoRSx5REFBb0Q7QUFTcEQsTUFBYSxXQUFXO0lBQXhCO1FBS1ksaUJBQVksR0FBNkIsRUFBRSxDQUFDO1FBSzVDLGlCQUFZLEdBQStCLEVBQUUsQ0FBQztJQTRGMUQsQ0FBQztJQTFGVSxNQUFNLENBQUMsS0FBWSxFQUFFLFlBQTBCLEVBQUUsR0FBRyxJQUFrQjtRQUV6RSxLQUFLLE1BQU0sR0FBRyxJQUFJLElBQUksRUFBRTtZQUVwQixNQUFNLE9BQU8sR0FBRywyQkFBWSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUU7Z0JBQ3RFLE9BQU8sRUFBQyxHQUFHLEVBQUUsSUFBSSxFQUFFLElBQUksR0FBRyxFQUFTLEVBQUMsQ0FBQztZQUN6QyxDQUFDLENBQUMsQ0FBQztZQUVILFFBQVEsWUFBWSxFQUFFO2dCQUVsQixLQUFLLEtBQUs7b0JBQ04sT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7b0JBQ3hCLE1BQU07Z0JBRVYsS0FBSyxRQUFRO29CQUNULE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO29CQUMzQixNQUFNO2FBRWI7WUFFRCxNQUFNLE9BQU8sR0FBRywyQkFBWSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUU7Z0JBQ3hFLE9BQU8sRUFBQyxHQUFHLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxFQUFFLEVBQUMsQ0FBQztZQUNsQyxDQUFDLENBQUMsQ0FBQztZQUVILE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBRTFCO0lBRUwsQ0FBQztJQUtNLE9BQU8sQ0FBQyxJQUFrQixFQUFFLFFBQWdCLENBQUM7UUFHaEQsTUFBTSxPQUFPLEdBQTRCLEVBQUUsQ0FBQztRQUU1QyxNQUFNLFVBQVUsR0FBRyxDQUFDLEdBQWUsRUFBRSxFQUFFO1lBSW5DLE1BQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUM7WUFFOUMsSUFBSSxDQUFFLGNBQWMsRUFBRTtnQkFFbEIsT0FBTzthQUNWO1lBRUQsTUFBTSxXQUFXLEdBQUcsY0FBYyxDQUFDLElBQUksQ0FBQztZQUV4QyxLQUFLLE1BQU0sVUFBVSxJQUFJLFdBQVcsRUFBRTtnQkFFbEMsTUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxVQUFVLENBQUMsQ0FBQztnQkFFckQsTUFBTSxXQUFXLEdBQUcsY0FBYyxDQUFDLElBQUksQ0FBQztnQkFFeEMsS0FBSyxNQUFNLFVBQVUsSUFBSSxXQUFXLEVBQUU7b0JBRWxDLE1BQU0sVUFBVSxHQUFHLDJCQUFZLENBQUMsZUFBZSxDQUFDLE9BQU8sRUFBRSxVQUFVLEVBQUUsR0FBRyxFQUFFO3dCQUN0RSxPQUFPLEVBQUMsR0FBRyxFQUFFLFVBQVUsRUFBRSxJQUFJLEVBQUUsQ0FBQyxFQUFDLENBQUM7b0JBQ3RDLENBQUMsQ0FBQyxDQUFDO29CQUVILEVBQUUsVUFBVSxDQUFDLElBQUksQ0FBQztpQkFFckI7YUFFSjtRQUVMLENBQUMsQ0FBQztRQUVGLEtBQUssTUFBTSxHQUFHLElBQUksSUFBSSxFQUFFO1lBQ3BCLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUNuQjtRQUtELE1BQU0sV0FBVyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDO2FBRXJDLE1BQU0sQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLENBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7YUFDL0MsTUFBTSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7YUFFbkMsSUFBSSxDQUFDLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFHakQsT0FBTyxlQUFNLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUUzQyxDQUFDO0NBRUo7QUF0R0Qsa0NBc0dDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtEaWN0aW9uYXJpZXN9IGZyb20gXCJwb2xhci1zaGFyZWQvc3JjL3V0aWwvRGljdGlvbmFyaWVzXCI7XG5pbXBvcnQge0FycmF5c30gZnJvbSBcInBvbGFyLXNoYXJlZC9zcmMvdXRpbC9BcnJheXNcIjtcblxuLyoqXG4gKiBSZWxhdGVkIHRhZyBpbmRleCBmb3IgaW4gbWVtb3J5IHJlbGF0ZWQgdGFncyBjb21wdXRhdGlvbi4gIFRoaXMgZG9lcyBub3RcbiAqIGFjdHVhbGx5IGltcGxlbWVudCBhbnkgZm9ybSBvZiBjb21wcmVzc2VkIGRhdGEgc3RydWN0dXJlIGJ1dCBpbnN0ZWFkIHN0b3Jlc1xuICogdGhlIHZhbHVlcyBkaXJlY3RseS4gIEEgdXNlcnMgcGVyc29uYWwgZG9jdW1lbnQgdGFnIGluZGV4IHdvbid0IHJlcXVpcmVcbiAqIG11Y2ggaW4tbWVtb3J5IHN0b3JhZ2UuICBNYXliZSAxMDBrIE1BWCBldmVuIGZvciBtYXNzaXZlIGRvY3VtZW50XG4gKiBjb2xsZWN0aW9ucy5cbiAqL1xuZXhwb3J0IGNsYXNzIFJlbGF0ZWRUYWdzIHtcblxuICAgIC8qKlxuICAgICAqIE1hcHMgZnJvbSB0aGUgdGFnIHRvIHRoZSBEb2NJRHMgZm9yIHRoaXMgdGFnLlxuICAgICAqL1xuICAgIHByaXZhdGUgdGFnRG9jc0luZGV4OiB7W3RhZzogc3RyaW5nXTogVGFnRG9jc30gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIE1hcHMgZnJvbSB0aGUgZG9jIElEIHRvIHRoZSB0YWdzIGZvciB0aGlzIGRvY3VtZW50LlxuICAgICAqL1xuICAgIHByaXZhdGUgZG9jVGFnc0luZGV4OiB7W2RvY0lEOiBzdHJpbmddOiBEb2NUYWdzfSA9IHt9O1xuXG4gICAgcHVibGljIHVwZGF0ZShkb2NJRDogRG9jSUQsIG11dGF0aW9uVHlwZTogTXV0YXRpb25UeXBlLCAuLi50YWdzOiBUYWdMaXRlcmFsW10pIHtcblxuICAgICAgICBmb3IgKGNvbnN0IHRhZyBvZiB0YWdzKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHRhZ01ldGEgPSBEaWN0aW9uYXJpZXMuY29tcHV0ZUlmQWJzZW50KHRoaXMudGFnRG9jc0luZGV4LCB0YWcsICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge3RhZywgZG9jczogbmV3IFNldDxEb2NJRD4oKX07XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgc3dpdGNoIChtdXRhdGlvblR5cGUpIHtcblxuICAgICAgICAgICAgICAgIGNhc2UgJ3NldCc6XG4gICAgICAgICAgICAgICAgICAgIHRhZ01ldGEuZG9jcy5hZGQoZG9jSUQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2RlbGV0ZSc6XG4gICAgICAgICAgICAgICAgICAgIHRhZ01ldGEuZG9jcy5kZWxldGUoZG9jSUQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBkb2NNZXRhID0gRGljdGlvbmFyaWVzLmNvbXB1dGVJZkFic2VudCh0aGlzLmRvY1RhZ3NJbmRleCwgZG9jSUQsICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge2RvYzogZG9jSUQsIHRhZ3M6IFtdfTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkb2NNZXRhLnRhZ3MucHVzaCh0YWcpO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGUgcmVsYXRlZCB0YWdzIGZvciB0aGUgZ2l2ZW4gdGFncy4uLlxuICAgICAqL1xuICAgIHB1YmxpYyBjb21wdXRlKHRhZ3M6IFRhZ0xpdGVyYWxbXSwgbGltaXQ6IG51bWJlciA9IDUpOiBUYWdIaXRbXSB7XG5cbiAgICAgICAgLy8ga2VlcCBhIHJ1bm5pbmcgaW5kZXggb2YgdGhlIGhpdHMgd2hlbiBjb21wdXRpbmcgdGhlIHJlbGF0ZWQgdGFncy5cbiAgICAgICAgY29uc3QgdGFnSGl0czoge1t0YWc6IHN0cmluZ106IFRhZ0hpdH0gPSB7fTtcblxuICAgICAgICBjb25zdCB1cGRhdGVIaXRzID0gKHRhZzogVGFnTGl0ZXJhbCkgPT4ge1xuXG4gICAgICAgICAgICAvLyBnZXQgYWxsIHRoZSBkb2N1bWVudHMgdGhhdCBtZW50aW9uIHRoaXMgdGFnXG5cbiAgICAgICAgICAgIGNvbnN0IGluZGV4ZWRUYWdNZXRhID0gdGhpcy50YWdEb2NzSW5kZXhbdGFnXTtcblxuICAgICAgICAgICAgaWYgKCEgaW5kZXhlZFRhZ01ldGEpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHRhZyBpc24ndCBpbmRleGVkIHlldC5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHJlbGF0ZWREb2NzID0gaW5kZXhlZFRhZ01ldGEuZG9jcztcblxuICAgICAgICAgICAgZm9yIChjb25zdCByZWxhdGVkRG9jIG9mIHJlbGF0ZWREb2NzKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleGVkRG9jTWV0YSA9IHRoaXMuZG9jVGFnc0luZGV4W3JlbGF0ZWREb2NdO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcmVsYXRlZFRhZ3MgPSBpbmRleGVkRG9jTWV0YS50YWdzO1xuXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCByZWxhdGVkVGFnIG9mIHJlbGF0ZWRUYWdzKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFnSGl0TWV0YSA9IERpY3Rpb25hcmllcy5jb21wdXRlSWZBYnNlbnQodGFnSGl0cywgcmVsYXRlZFRhZywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHt0YWc6IHJlbGF0ZWRUYWcsIGhpdHM6IDB9O1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICArK3RhZ0hpdE1ldGEuaGl0cztcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yIChjb25zdCB0YWcgb2YgdGFncykge1xuICAgICAgICAgICAgdXBkYXRlSGl0cyh0YWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2Ugbm93IGhhdmUgYWxsIHRoZSB0YWdzIHdpdGggaGl0cy4uIHNvIHNjb3JlIHRoZW0gYW5kIHRoZW4gY29tcHV0ZVxuICAgICAgICAvLyB0aGUgdG9wIE4gZm9yIG5vdy5cblxuICAgICAgICBjb25zdCB0YWdIaXRzRGVzYyA9IE9iamVjdC52YWx1ZXModGFnSGl0cylcbiAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgaW5wdXQgdGFncyBmcm9tIHRoZSByZXN1bHRzLi4uXG4gICAgICAgICAgICAuZmlsdGVyKGN1cnJlbnQgPT4gISB0YWdzLmluY2x1ZGVzKGN1cnJlbnQudGFnKSlcbiAgICAgICAgICAgIC5maWx0ZXIoY3VycmVudCA9PiBjdXJyZW50LmhpdHMgPiAxKVxuICAgICAgICAgICAgLy8gc29ydCB0aGUgcmVzdWx0cyBkZXNjZW5kaW5nLlxuICAgICAgICAgICAgLnNvcnQoKGhpdDAsIGhpdDEpID0+IGhpdDEuaGl0cyAtIGhpdDAuaGl0cyk7XG5cblxuICAgICAgICByZXR1cm4gQXJyYXlzLmhlYWQodGFnSGl0c0Rlc2MsIGxpbWl0KTtcblxuICAgIH1cblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRhZ0RvY3Mge1xuICAgIHJlYWRvbmx5IHRhZzogVGFnTGl0ZXJhbDtcbiAgICByZWFkb25seSBkb2NzOiBTZXQ8RG9jSUQ+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERvY1RhZ3Mge1xuICAgIHRhZ3M6IHN0cmluZ1tdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRhZ0hpdCB7XG5cbiAgICByZWFkb25seSB0YWc6IFRhZ0xpdGVyYWw7XG4gICAgaGl0czogbnVtYmVyO1xuXG59XG5cbmV4cG9ydCB0eXBlIERvY0lEID0gc3RyaW5nO1xuXG4vKipcbiAqIEEgbGl0ZXJhbCB0YWcgdmFsdWUgYXMgYSBzdHJpbmcuXG4gKi9cbmV4cG9ydCB0eXBlIFRhZ0xpdGVyYWwgPSBzdHJpbmc7XG5cbmV4cG9ydCB0eXBlIE11dGF0aW9uVHlwZSA9ICdzZXQnIHwgJ2RlbGV0ZSc7XG4iXX0=