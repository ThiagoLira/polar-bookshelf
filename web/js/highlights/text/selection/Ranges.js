"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Preconditions_1 = require("polar-shared/src/Preconditions");
const Logger_1 = require("polar-shared/src/logger/Logger");
const log = Logger_1.Logger.create();
class Ranges {
    static cloneRanges(ranges) {
        return ranges.map(range => range.cloneRange());
    }
    static splitTextNode(container, offset, useStartBoundary) {
        if (container.nodeType !== Node.TEXT_NODE &&
            container.nodeType !== Node.COMMENT_NODE &&
            container.nodeType !== Node.CDATA_SECTION_NODE) {
            if (offset > 0) {
                return container.childNodes[offset];
            }
            return container;
        }
        const newNode = container.splitText(offset);
        if (useStartBoundary) {
            return newNode;
        }
        else {
            return newNode.previousSibling;
        }
    }
    static toHTML(range) {
        let result = "";
        const docFragment = range.cloneContents();
        docFragment.childNodes.forEach(childNode => {
            if (childNode.nodeType === Node.TEXT_NODE) {
                result += childNode.textContent;
            }
            else {
                result += childNode.outerHTML;
            }
        });
        return result;
    }
    static toText(range) {
        let result = "";
        const docFragment = range.cloneContents();
        docFragment.childNodes.forEach(childNode => {
            if (childNode.nodeType === Node.TEXT_NODE) {
                result += childNode.textContent;
            }
            else {
                result += childNode.innerText;
            }
        });
        return result;
    }
    static getTextNodes(range) {
        Preconditions_1.Preconditions.assertPresent(range, "range");
        const startNode = Ranges.splitTextNode(range.startContainer, range.startOffset, true);
        const endNode = Ranges.splitTextNode(range.endContainer, range.endOffset, false);
        Preconditions_1.Preconditions.assertPresent(startNode, "startNode");
        Preconditions_1.Preconditions.assertPresent(endNode, "endNode");
        const doc = range.startContainer.ownerDocument;
        const treeWalker = doc.createTreeWalker(range.commonAncestorContainer);
        const result = [];
        let node;
        let inSelection = false;
        while (node = treeWalker.nextNode()) {
            if (startNode === node) {
                inSelection = true;
                break;
            }
        }
        while (node) {
            if (node.nodeType === Node.TEXT_NODE) {
                result.push(node);
            }
            if (endNode === node) {
                break;
            }
            node = treeWalker.nextNode();
        }
        return result;
    }
    static hasText(range) {
        Preconditions_1.Preconditions.assertNotNull(range, "range");
        const startNode = Ranges.splitTextNode(range.startContainer, range.startOffset, true);
        const endNode = Ranges.splitTextNode(range.endContainer, range.endOffset, false);
        Preconditions_1.Preconditions.assertPresent(startNode, "startNode");
        Preconditions_1.Preconditions.assertPresent(endNode, "endNode");
        const doc = range.startContainer.ownerDocument;
        const treeWalker = doc.createTreeWalker(range.commonAncestorContainer);
        const result = [];
        let node;
        let inSelection = false;
        while (node = treeWalker.nextNode()) {
            if (startNode === node) {
                inSelection = true;
                break;
            }
        }
        while (node) {
            if (node.nodeType === Node.TEXT_NODE) {
                if (node.textContent && node.textContent.trim() !== '') {
                    return true;
                }
            }
            if (endNode === node) {
                break;
            }
            node = treeWalker.nextNode();
        }
        return false;
    }
    static describeNode(node) {
        return node.cloneNode(false).outerHTML;
    }
}
exports.Ranges = Ranges;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmFuZ2VzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiUmFuZ2VzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsa0VBQTZEO0FBQzdELDJEQUFzRDtBQUd0RCxNQUFNLEdBQUcsR0FBRyxlQUFNLENBQUMsTUFBTSxFQUFFLENBQUM7QUFFNUIsTUFBYSxNQUFNO0lBT1IsTUFBTSxDQUFDLFdBQVcsQ0FBQyxNQUFlO1FBQ3JDLE9BQU8sTUFBTSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxVQUFVLEVBQUUsQ0FBQyxDQUFDO0lBQ25ELENBQUM7SUFNTSxNQUFNLENBQUMsYUFBYSxDQUFDLFNBQWUsRUFDZixNQUFjLEVBQ2QsZ0JBQXlCO1FBRWpELElBQUksU0FBUyxDQUFDLFFBQVEsS0FBSyxJQUFJLENBQUMsU0FBUztZQUNyQyxTQUFTLENBQUMsUUFBUSxLQUFLLElBQUksQ0FBQyxZQUFZO1lBQ3hDLFNBQVMsQ0FBQyxRQUFRLEtBQUssSUFBSSxDQUFDLGtCQUFrQixFQUFFO1lBRWhELElBQUksTUFBTSxHQUFHLENBQUMsRUFBRTtnQkFRWixPQUFPLFNBQVMsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUM7YUFFdkM7WUFFRCxPQUFPLFNBQVMsQ0FBQztTQUVwQjtRQUdELE1BQU0sT0FBTyxHQUFXLFNBQVUsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFckQsSUFBSSxnQkFBZ0IsRUFBRTtZQUNsQixPQUFPLE9BQU8sQ0FBQztTQUNsQjthQUFNO1lBQ0gsT0FBTyxPQUFPLENBQUMsZUFBZ0IsQ0FBQztTQUNuQztJQUVMLENBQUM7SUFNTSxNQUFNLENBQUMsTUFBTSxDQUFDLEtBQVk7UUFFN0IsSUFBSSxNQUFNLEdBQUcsRUFBRSxDQUFDO1FBRWhCLE1BQU0sV0FBVyxHQUFHLEtBQUssQ0FBQyxhQUFhLEVBQUUsQ0FBQztRQUUxQyxXQUFXLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FB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L3NyYy9QcmVjb25kaXRpb25zJztcbmltcG9ydCB7TG9nZ2VyfSBmcm9tICdwb2xhci1zaGFyZWQvc3JjL2xvZ2dlci9Mb2dnZXInO1xuaW1wb3J0IHtOb2RlVHlwZXN9IGZyb20gJy4vTm9kZVR5cGVzJztcblxuY29uc3QgbG9nID0gTG9nZ2VyLmNyZWF0ZSgpO1xuXG5leHBvcnQgY2xhc3MgUmFuZ2VzIHtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBkdXBsaWNhdGUgb2YgdGhlIGdpdmVuIHJhbmdlcyBzbyB0aGF0IHdlIGNhbiBrbm93IHRoYXQgd2UgaGF2ZVxuICAgICAqIG91ciBvd24gdW5pcXVlIGNvcGllcyB0aGF0IGNhbid0IGJlIHJlc2V0LlxuICAgICAqXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBjbG9uZVJhbmdlcyhyYW5nZXM6IFJhbmdlW10pIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlcy5tYXAocmFuZ2UgPT4gcmFuZ2UuY2xvbmVSYW5nZSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTcGxpdCBhIHRleHQgbm9kZSBhbmQgZ2V0IHRoZSBuZXcgLyBzdGFydGluZyBub2RlLlxuICAgICAqXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBzcGxpdFRleHROb2RlKGNvbnRhaW5lcjogTm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBudW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZVN0YXJ0Qm91bmRhcnk6IGJvb2xlYW4pIHtcblxuICAgICAgICBpZiAoY29udGFpbmVyLm5vZGVUeXBlICE9PSBOb2RlLlRFWFRfTk9ERSAmJlxuICAgICAgICAgICAgY29udGFpbmVyLm5vZGVUeXBlICE9PSBOb2RlLkNPTU1FTlRfTk9ERSAmJlxuICAgICAgICAgICAgY29udGFpbmVyLm5vZGVUeXBlICE9PSBOb2RlLkNEQVRBX1NFQ1RJT05fTk9ERSkge1xuXG4gICAgICAgICAgICBpZiAob2Zmc2V0ID4gMCkge1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHN0YXJ0Tm9kZSBpcyBhIE5vZGUgb2YgdHlwZSBUZXh0LCBDb21tZW50LCBvclxuICAgICAgICAgICAgICAgIC8vIENEQVRBU2VjdGlvbiwgdGhlbiBzdGFydE9mZnNldCBpcyB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnNcbiAgICAgICAgICAgICAgICAvLyBmcm9tIHRoZSBzdGFydCBvZiBzdGFydE5vZGUuIEZvciBvdGhlciBOb2RlIHR5cGVzLFxuICAgICAgICAgICAgICAgIC8vIHN0YXJ0T2Zmc2V0IGlzIHRoZSBudW1iZXIgb2YgY2hpbGQgbm9kZXMgYmV0d2VlbiB0aGUgc3RhcnQgb2ZcbiAgICAgICAgICAgICAgICAvLyB0aGUgc3RhcnROb2RlLlxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5jaGlsZE5vZGVzW29mZnNldF07XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogdGhpcyBpcyBub3QgbmVjZXNzYXJpbHkgYSB0ZXh0IG5vZGUgYnV0IHdlJ3JlIGNhc3RpbmcgaXQuLi5cbiAgICAgICAgY29uc3QgbmV3Tm9kZSA9ICg8VGV4dD4gY29udGFpbmVyKS5zcGxpdFRleHQob2Zmc2V0KTtcblxuICAgICAgICBpZiAodXNlU3RhcnRCb3VuZGFyeSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ld05vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3Tm9kZS5wcmV2aW91c1NpYmxpbmchO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gSFRNTCBjb250ZW50IG9mIHRoZSByYW5nZSBzZWxlY3RlZC5cbiAgICAgKlxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgdG9IVE1MKHJhbmdlOiBSYW5nZSkge1xuXG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuXG4gICAgICAgIGNvbnN0IGRvY0ZyYWdtZW50ID0gcmFuZ2UuY2xvbmVDb250ZW50cygpO1xuXG4gICAgICAgIGRvY0ZyYWdtZW50LmNoaWxkTm9kZXMuZm9yRWFjaChjaGlsZE5vZGUgPT4ge1xuXG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBjaGlsZE5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAoPEhUTUxFbGVtZW50PiBjaGlsZE5vZGUpLm91dGVySFRNTDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyB0b1RleHQocmFuZ2U6IFJhbmdlKSB7XG5cbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG5cbiAgICAgICAgY29uc3QgZG9jRnJhZ21lbnQgPSByYW5nZS5jbG9uZUNvbnRlbnRzKCk7XG5cbiAgICAgICAgZG9jRnJhZ21lbnQuY2hpbGROb2Rlcy5mb3JFYWNoKGNoaWxkTm9kZSA9PiB7XG5cbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGNoaWxkTm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICg8SFRNTEVsZW1lbnQ+IGNoaWxkTm9kZSkuaW5uZXJUZXh0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdGV4dCBub2RlcyBmb3IgcmFuZ2UuIE9wdGlvbmFsbHkgc3BsaXR0aW5nIHRoZSB0ZXh0IGlmIG5lY2Vzc2FyeVxuICAgICAqXG4gICAgICogQHBhcmFtIHJhbmdlIHtSYW5nZX1cbiAgICAgKiBAcmV0dXJuIHtBcnJheTxOb2RlPn1cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGdldFRleHROb2RlcyhyYW5nZTogUmFuZ2UpIHtcblxuICAgICAgICBQcmVjb25kaXRpb25zLmFzc2VydFByZXNlbnQocmFuZ2UsIFwicmFuZ2VcIik7XG5cbiAgICAgICAgLy8gV2Ugc3RhcnQgd2Fsa2luZyB0aGUgdHJlZSB1bnRpbCB3ZSBmaW5kIHRoZSBzdGFydCBub2RlLCB0aGVuIHdlXG4gICAgICAgIC8vIGVuYWJsZSBzZXQgaW5TZWxlY3Rpb24gPSB0cnVlLi4uIHRoZW4gd2hlbiB3ZSBleGl0IHRoZSBzZWxlY3Rpb24gYnlcbiAgICAgICAgLy8gaGl0dGluZyB0aGUgZW5kIG5vZGUgd2UganVzdCByZXR1cm4gb3V0IG9mIHRoZSB3aGlsZSBsb29wIGFuZCB3ZSdyZVxuICAgICAgICAvLyBkb25lXG5cbiAgICAgICAgY29uc3Qgc3RhcnROb2RlID0gUmFuZ2VzLnNwbGl0VGV4dE5vZGUocmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0LCB0cnVlKTtcbiAgICAgICAgY29uc3QgZW5kTm9kZSA9IFJhbmdlcy5zcGxpdFRleHROb2RlKHJhbmdlLmVuZENvbnRhaW5lciwgcmFuZ2UuZW5kT2Zmc2V0LCBmYWxzZSk7XG5cbiAgICAgICAgUHJlY29uZGl0aW9ucy5hc3NlcnRQcmVzZW50KHN0YXJ0Tm9kZSwgXCJzdGFydE5vZGVcIik7XG4gICAgICAgIFByZWNvbmRpdGlvbnMuYXNzZXJ0UHJlc2VudChlbmROb2RlLCBcImVuZE5vZGVcIik7XG5cbiAgICAgICAgY29uc3QgZG9jID0gcmFuZ2Uuc3RhcnRDb250YWluZXIub3duZXJEb2N1bWVudCE7XG5cbiAgICAgICAgLy8gdXNlIFRyZWVXYWxrZXIgdG8gd2FsayB0aGUgY29tbW9uQW5jZXN0b3JDb250YWluZXIgYW5kIHdlIHNlZSB3aGljaFxuICAgICAgICAvLyByYW5nZXMgY29udGFpbiB3aGljaCB0ZXh0IG5vZGVzLlxuICAgICAgICBjb25zdCB0cmVlV2Fsa2VyID0gZG9jLmNyZWF0ZVRyZWVXYWxrZXIocmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXIpO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGxldCBub2RlO1xuXG4gICAgICAgIGxldCBpblNlbGVjdGlvbiA9IGZhbHNlO1xuXG4gICAgICAgIC8vICoqIHRyYXZlcnNlIHVudGlsIHdlIGZpbmQgdGhlIHN0YXJ0XG4gICAgICAgIHdoaWxlIChub2RlID0gdHJlZVdhbGtlci5uZXh0Tm9kZSgpKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnROb2RlID09PSBub2RlKSB7XG4gICAgICAgICAgICAgICAgaW5TZWxlY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyAqKiBub3cga2VlcCBjb25zdW1pbmcgdW50aWwgd2UgaGl0IHRoZSBsYXN0IG5vZGUuXG5cbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcblxuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlbmROb2RlID09PSBub2RlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vZGUgPSB0cmVlV2Fsa2VyLm5leHROb2RlKCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaW1pbGFyIHRvIGdldFRleHROb2RlcyBidXQgd2UgcmV0dXJuIHRydWUgaWYgdGhlIG5vZGVzIGhhdmUgdGV4dCBpbiB0aGVtLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmFuZ2VcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGhhc1RleHQocmFuZ2U6IFJhbmdlKSB7XG5cbiAgICAgICAgLy8gVE9ETyBtYXNzaXZlIGFtb3VudCBvZiBkdXBsaWNhdGlvbiB3aXRoIGdldFRleHROb2RlcyBhbmQgbWlnaHQgYmVcbiAgICAgICAgLy8gdmFsdWFibGUgdG8gcmV3b3JrIHRoaXMgdG8gYSB2aXNpdG9yIHBhdHRlcm4gd2hpY2ggYWNjZXB0cyBhIGZ1bmN0aW9uXG4gICAgICAgIC8vIHdoaWNoIHJldHVybnMgdHJ1ZSBpZiB3ZSBzaG91bGQga2VlcCBtb3ZpbmcgZm9yd2FyZC5cblxuICAgICAgICBQcmVjb25kaXRpb25zLmFzc2VydE5vdE51bGwocmFuZ2UsIFwicmFuZ2VcIik7XG5cbiAgICAgICAgLy8gV2Ugc3RhcnQgd2Fsa2luZyB0aGUgdHJlZSB1bnRpbCB3ZSBmaW5kIHRoZSBzdGFydCBub2RlLCB0aGVuIHdlXG4gICAgICAgIC8vIGVuYWJsZSBzZXQgaW5TZWxlY3Rpb24gPSB0cnVlLi4uIHRoZW4gd2hlbiB3ZSBleGl0IHRoZSBzZWxlY3Rpb24gYnlcbiAgICAgICAgLy8gaGl0dGluZyB0aGUgZW5kIG5vZGUgd2UganVzdCByZXR1cm4gb3V0IG9mIHRoZSB3aGlsZSBsb29wIGFuZCB3ZSdyZVxuICAgICAgICAvLyBkb25lXG5cbiAgICAgICAgY29uc3Qgc3RhcnROb2RlID0gUmFuZ2VzLnNwbGl0VGV4dE5vZGUocmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0LCB0cnVlKTtcbiAgICAgICAgY29uc3QgZW5kTm9kZSA9IFJhbmdlcy5zcGxpdFRleHROb2RlKHJhbmdlLmVuZENvbnRhaW5lciwgcmFuZ2UuZW5kT2Zmc2V0LCBmYWxzZSk7XG5cbiAgICAgICAgUHJlY29uZGl0aW9ucy5hc3NlcnRQcmVzZW50KHN0YXJ0Tm9kZSwgXCJzdGFydE5vZGVcIik7XG4gICAgICAgIFByZWNvbmRpdGlvbnMuYXNzZXJ0UHJlc2VudChlbmROb2RlLCBcImVuZE5vZGVcIik7XG5cbiAgICAgICAgY29uc3QgZG9jID0gcmFuZ2Uuc3RhcnRDb250YWluZXIub3duZXJEb2N1bWVudCE7XG5cbiAgICAgICAgLy8gdXNlIFRyZWVXYWxrZXIgdG8gd2FsayB0aGUgY29tbW9uQW5jZXN0b3JDb250YWluZXIgYW5kIHdlIHNlZSB3aGljaFxuICAgICAgICAvLyByYW5nZXMgY29udGFpbiB3aGljaCB0ZXh0IG5vZGVzLlxuICAgICAgICBjb25zdCB0cmVlV2Fsa2VyID0gZG9jLmNyZWF0ZVRyZWVXYWxrZXIocmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXIpO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGxldCBub2RlO1xuXG4gICAgICAgIGxldCBpblNlbGVjdGlvbiA9IGZhbHNlO1xuXG4gICAgICAgIC8vICoqIHRyYXZlcnNlIHVudGlsIHdlIGZpbmQgdGhlIHN0YXJ0XG4gICAgICAgIHdoaWxlIChub2RlID0gdHJlZVdhbGtlci5uZXh0Tm9kZSgpKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnROb2RlID09PSBub2RlKSB7XG4gICAgICAgICAgICAgICAgaW5TZWxlY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyAqKiBub3cga2VlcCBjb25zdW1pbmcgdW50aWwgd2UgaGl0IHRoZSBsYXN0IG5vZGUuXG5cbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcblxuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAobm9kZS50ZXh0Q29udGVudCAmJiBub2RlLnRleHRDb250ZW50LnRyaW0oKSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlbmROb2RlID09PSBub2RlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vZGUgPSB0cmVlV2Fsa2VyLm5leHROb2RlKCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgZGVzY3JpYmVOb2RlKG5vZGU6IE5vZGUpIHtcbiAgICAgICAgcmV0dXJuICg8SFRNTEVsZW1lbnQ+IG5vZGUuY2xvbmVOb2RlKGZhbHNlKSkub3V0ZXJIVE1MO1xuICAgIH1cblxufVxuIl19