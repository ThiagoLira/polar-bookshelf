"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Preconditions_1 = require("polar-shared/src/Preconditions");
const Logger_1 = require("polar-shared/src/logger/Logger");
const Optional_1 = require("polar-shared/src/util/ts/Optional");
const Reducers_1 = require("polar-shared/src/util/Reducers");
const log = Logger_1.Logger.create();
class Descriptors {
    static calculateDocDimensions(descriptor) {
        let width = 800;
        let minHeight = 1100;
        if (!descriptor) {
            return { width, minHeight };
        }
        if (descriptor.browser) {
            width = descriptor.browser.deviceEmulation.screenSize.width;
            log.info("Setting width from device emulation: " + width);
        }
        const scrollBox = this.computeScrollBox(descriptor);
        if (scrollBox.isPresent() && scrollBox.get().width > width) {
            if (!Preconditions_1.isPresent(scrollBox.get().widthOverflow) ||
                scrollBox.get().widthOverflow === 'visible') {
                width = scrollBox.get().width;
            }
            log.info("Setting width from scroll settings: " + width);
        }
        minHeight = (11 / 8.5) * width;
        return { width, minHeight };
    }
    static computeScrollBox(descriptor) {
        return this.computeScrollBoxFromBoxes(descriptor.scrollBox, descriptor.scroll);
    }
    static computeScrollBoxFromBoxes(scrollBox, scroll) {
        return [Optional_1.Optional.of(scrollBox), Optional_1.Optional.of(scroll)]
            .filter(current => current.isPresent())
            .filter(current => current.map(scrollBox => this.isScrollBox(scrollBox)).getOrElse(false))
            .reduce(Reducers_1.Reducers.FIRST, Optional_1.Optional.empty());
    }
    static isScrollBox(scrollBox) {
        return typeof scrollBox.width === 'number' && typeof scrollBox.height === 'number';
    }
}
exports.Descriptors = Descriptors;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRGVzY3JpcHRvcnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJEZXNjcmlwdG9ycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLGtFQUFrRTtBQUVsRSwyREFBc0Q7QUFFdEQsZ0VBQTJEO0FBQzNELDZEQUF3RDtBQUd4RCxNQUFNLEdBQUcsR0FBRyxlQUFNLENBQUMsTUFBTSxFQUFFLENBQUM7QUFFNUIsTUFBYSxXQUFXO0lBRWIsTUFBTSxDQUFDLHNCQUFzQixDQUFDLFVBQXdCO1FBR3pELElBQUksS0FBSyxHQUFHLEdBQUcsQ0FBQztRQUNoQixJQUFJLFNBQVMsR0FBRyxJQUFJLENBQUM7UUFFckIsSUFBSSxDQUFDLFVBQVUsRUFBRTtZQUNiLE9BQU8sRUFBQyxLQUFLLEVBQUUsU0FBUyxFQUFDLENBQUM7U0FDN0I7UUFFRCxJQUFJLFVBQVUsQ0FBQyxPQUFPLEVBQUU7WUFHcEIsS0FBSyxHQUFHLFVBQVUsQ0FBQyxPQUFPLENBQUMsZUFBZSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUM7WUFFNUQsR0FBRyxDQUFDLElBQUksQ0FBQyx1Q0FBdUMsR0FBRyxLQUFLLENBQUMsQ0FBQztTQUU3RDtRQUVELE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUVwRCxJQUFJLFNBQVMsQ0FBQyxTQUFTLEVBQUUsSUFBSSxTQUFTLENBQUMsR0FBRyxFQUFFLENBQUMsS0FBSyxHQUFHLEtBQUssRUFBRztZQU16RCxJQUFJLENBQUMseUJBQVMsQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFLENBQUMsYUFBYSxDQUFDO2dCQUN6QyxTQUFTLENBQUMsR0FBRyxFQUFFLENBQUMsYUFBYSxLQUFLLFNBQVMsRUFBRTtnQkFFN0MsS0FBSyxHQUFHLFNBQVMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUM7YUFFakM7WUFFRCxHQUFHLENBQUMsSUFBSSxDQUFDLHNDQUFzQyxHQUFHLEtBQUssQ0FBQyxDQUFDO1NBRTVEO1FBSUQsU0FBUyxHQUFHLENBQUMsRUFBRSxHQUFHLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQztRQUUvQixPQUFPLEVBQUMsS0FBSyxFQUFFLFNBQVMsRUFBQyxDQUFDO0lBRTlCLENBQUM7SUFFTSxNQUFNLENBQUMsZ0JBQWdCLENBQUMsVUFBdUI7UUFDbEQsT0FBTyxJQUFJLENBQUMseUJBQXlCLENBQUMsVUFBVSxDQUFDLFNBQVMsRUFBRSxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDbkYsQ0FBQztJQUVNLE1BQU0sQ0FBQyx5QkFBeUIsQ0FBQyxTQUFxQixFQUFFLE1BQWtCO1FBRTdFLE9BQU8sQ0FBQyxtQkFBUSxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsRUFBRSxtQkFBUSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQzthQUMvQyxNQUFNLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsU0FBUyxFQUFFLENBQUM7YUFDdEMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7YUFDekYsTUFBTSxDQUFDLG1CQUFRLENBQUMsS0FBSyxFQUFFLG1CQUFRLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztJQUVsRCxDQUFDO0lBRU0sTUFBTSxDQUFDLFdBQVcsQ0FBQyxTQUFvQjtRQUUxQyxPQUFPLE9BQU8sU0FBUyxDQUFDLEtBQUssS0FBSyxRQUFRLElBQUksT0FBTyxTQUFTLENBQUMsTUFBTSxLQUFLLFFBQVEsQ0FBQztJQUV2RixDQUFDO0NBR0o7QUFwRUQsa0NBb0VDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtpc1ByZXNlbnQsIG5vdE51bGx9IGZyb20gJ3BvbGFyLXNoYXJlZC9zcmMvUHJlY29uZGl0aW9ucyc7XG5pbXBvcnQge1BIWk1ldGFkYXRhfSBmcm9tICcuLi8uLi9waHovUEhaTWV0YWRhdGEnO1xuaW1wb3J0IHtMb2dnZXJ9IGZyb20gJ3BvbGFyLXNoYXJlZC9zcmMvbG9nZ2VyL0xvZ2dlcic7XG5pbXBvcnQge1Njcm9sbEJveH0gZnJvbSAncG9sYXItY29udGVudC1jYXB0dXJlL3NyYy9jYXB0dXJlL0NhcHR1cmVkJztcbmltcG9ydCB7T3B0aW9uYWx9IGZyb20gJ3BvbGFyLXNoYXJlZC9zcmMvdXRpbC90cy9PcHRpb25hbCc7XG5pbXBvcnQge1JlZHVjZXJzfSBmcm9tICdwb2xhci1zaGFyZWQvc3JjL3V0aWwvUmVkdWNlcnMnO1xuaW1wb3J0IHtJRGltZW5zaW9uc30gZnJvbSBcIi4uLy4uL3V0aWwvSURpbWVuc2lvbnNcIjtcblxuY29uc3QgbG9nID0gTG9nZ2VyLmNyZWF0ZSgpO1xuXG5leHBvcnQgY2xhc3MgRGVzY3JpcHRvcnMge1xuXG4gICAgcHVibGljIHN0YXRpYyBjYWxjdWxhdGVEb2NEaW1lbnNpb25zKGRlc2NyaXB0b3I/OiBQSFpNZXRhZGF0YSk6IERvY0RpbWVuc2lvbnMge1xuXG4gICAgICAgIC8vIHRoZSBkZWZhdWx0IHdpZHRoXG4gICAgICAgIGxldCB3aWR0aCA9IDgwMDtcbiAgICAgICAgbGV0IG1pbkhlaWdodCA9IDExMDA7XG5cbiAgICAgICAgaWYgKCFkZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4ge3dpZHRoLCBtaW5IZWlnaHR9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlc2NyaXB0b3IuYnJvd3Nlcikge1xuXG4gICAgICAgICAgICAvLyB1c2UgdGhlIHNjcmVlbiB3aWR0aCBmcm9tIHRoZSBlbXVsYXRlZCBkZXZpY2VcbiAgICAgICAgICAgIHdpZHRoID0gZGVzY3JpcHRvci5icm93c2VyLmRldmljZUVtdWxhdGlvbi5zY3JlZW5TaXplLndpZHRoO1xuXG4gICAgICAgICAgICBsb2cuaW5mbyhcIlNldHRpbmcgd2lkdGggZnJvbSBkZXZpY2UgZW11bGF0aW9uOiBcIiArIHdpZHRoKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2Nyb2xsQm94ID0gdGhpcy5jb21wdXRlU2Nyb2xsQm94KGRlc2NyaXB0b3IpO1xuXG4gICAgICAgIGlmIChzY3JvbGxCb3guaXNQcmVzZW50KCkgJiYgc2Nyb2xsQm94LmdldCgpLndpZHRoID4gd2lkdGggKSB7XG5cbiAgICAgICAgICAgIC8vIHdlIGhhdmUgYSBkb2N1bWVudCB0aGF0IGlzbid0IG1vYmlsZSBhd2FyZSBhbmQgaGFyZCBjb2RlZCB0byBhXG4gICAgICAgICAgICAvLyBzcGVjaWZpYyB3aWR0aCBncmVhdGVyIHRoYW4gb3VyIGRlZmF1bHQgd2lkdGguICBUaGlzIGlzIGEgbmV3XG4gICAgICAgICAgICAvLyBzZXR0aW5nIHNvIHdlIGhhdmUgdG8gbWFrZSBzdXJlIHRoZSBrZXkgaXMgaW4gdGhlIGRlc2NyaXB0b3IuXG5cbiAgICAgICAgICAgIGlmICghaXNQcmVzZW50KHNjcm9sbEJveC5nZXQoKS53aWR0aE92ZXJmbG93KSB8fFxuICAgICAgICAgICAgICAgIHNjcm9sbEJveC5nZXQoKS53aWR0aE92ZXJmbG93ID09PSAndmlzaWJsZScpIHtcblxuICAgICAgICAgICAgICAgIHdpZHRoID0gc2Nyb2xsQm94LmdldCgpLndpZHRoO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxvZy5pbmZvKFwiU2V0dGluZyB3aWR0aCBmcm9tIHNjcm9sbCBzZXR0aW5nczogXCIgKyB3aWR0aCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHBhZ2UgaGVpZ2h0IHNpemUgc2hvdWxkIGJlIGEgZnVuY3Rpb24gb2YgOC41eDExXG5cbiAgICAgICAgbWluSGVpZ2h0ID0gKDExIC8gOC41KSAqIHdpZHRoO1xuXG4gICAgICAgIHJldHVybiB7d2lkdGgsIG1pbkhlaWdodH07XG5cbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGNvbXB1dGVTY3JvbGxCb3goZGVzY3JpcHRvcjogUEhaTWV0YWRhdGEpOiBPcHRpb25hbDxTY3JvbGxCb3g+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZVNjcm9sbEJveEZyb21Cb3hlcyhkZXNjcmlwdG9yLnNjcm9sbEJveCwgZGVzY3JpcHRvci5zY3JvbGwpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgY29tcHV0ZVNjcm9sbEJveEZyb21Cb3hlcyhzY3JvbGxCb3g/OiBTY3JvbGxCb3gsIHNjcm9sbD86IFNjcm9sbEJveCk6IE9wdGlvbmFsPFNjcm9sbEJveD4ge1xuXG4gICAgICAgIHJldHVybiBbT3B0aW9uYWwub2Yoc2Nyb2xsQm94KSwgT3B0aW9uYWwub2Yoc2Nyb2xsKV1cbiAgICAgICAgICAgIC5maWx0ZXIoY3VycmVudCA9PiBjdXJyZW50LmlzUHJlc2VudCgpKVxuICAgICAgICAgICAgLmZpbHRlcihjdXJyZW50ID0+IGN1cnJlbnQubWFwKHNjcm9sbEJveCA9PiB0aGlzLmlzU2Nyb2xsQm94KHNjcm9sbEJveCkpLmdldE9yRWxzZShmYWxzZSkpXG4gICAgICAgICAgICAucmVkdWNlKFJlZHVjZXJzLkZJUlNULCBPcHRpb25hbC5lbXB0eSgpKTtcblxuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgaXNTY3JvbGxCb3goc2Nyb2xsQm94OiBTY3JvbGxCb3gpIHtcblxuICAgICAgICByZXR1cm4gdHlwZW9mIHNjcm9sbEJveC53aWR0aCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHNjcm9sbEJveC5oZWlnaHQgPT09ICdudW1iZXInO1xuXG4gICAgfVxuXG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBEb2NEaW1lbnNpb25zIHtcbiAgICB3aWR0aDogbnVtYmVyO1xuICAgIG1pbkhlaWdodDogbnVtYmVyO1xuXG59XG4iXX0=