"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const electron_1 = require("electron");
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const Preconditions_1 = require("polar-shared/src/Preconditions");
const URLs_1 = require("polar-shared/src/util/URLs");
const USE_FILE_URL = true;
class ResourcePaths {
    static absoluteFromRelativePath(relativePath) {
        const baseDirs = ResourcePaths.getBaseDirs();
        for (const baseDir of baseDirs) {
            const absolutePath = path_1.default.resolve(baseDir, relativePath);
            try {
                fs_1.default.readFileSync(absolutePath);
                return absolutePath;
            }
            catch (e) {
            }
        }
        throw new Error(`No file found for ${relativePath} in baseDirs: ` + JSON.stringify(baseDirs));
    }
    static resourceURLFromRelativeURL(relativeURL, useFileURL = USE_FILE_URL) {
        let relativePath = relativeURL;
        let queryData = "";
        if (relativeURL.indexOf("?") !== -1) {
            relativePath = relativeURL.substring(0, relativeURL.indexOf("?"));
            queryData = relativeURL.substring(relativeURL.indexOf("?"));
        }
        if (useFileURL) {
            const absolutePath = ResourcePaths.absoluteFromRelativePath(relativePath);
            return 'file://' + absolutePath + queryData;
        }
        else {
            const computeBase = () => {
                if (typeof window !== 'undefined' && window.location) {
                    return URLs_1.URLs.toBase(window.location.href);
                }
                return "http://localhost:8500";
            };
            const base = computeBase();
            return base + relativeURL;
        }
    }
    static getBaseDirs() {
        const baseDirs = [];
        if (!Preconditions_1.isPresent(electron_1.app)) {
            baseDirs.push(electron_1.remote.app.getAppPath());
        }
        else {
            baseDirs.push(electron_1.app.getAppPath());
        }
        baseDirs.push(process.cwd());
        return baseDirs;
    }
}
exports.ResourcePaths = ResourcePaths;
class AppPathException extends Error {
}
exports.AppPathException = AppPathException;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmVzb3VyY2VQYXRocy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIlJlc291cmNlUGF0aHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFDQSx1Q0FBcUM7QUFDckMsZ0RBQXdCO0FBQ3hCLDRDQUFvQjtBQUNwQixrRUFBeUQ7QUFDekQscURBQWdEO0FBRWhELE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQztBQVMxQixNQUFhLGFBQWE7SUFLZixNQUFNLENBQUMsd0JBQXdCLENBQUMsWUFBb0I7UUFLdkQsTUFBTSxRQUFRLEdBQUcsYUFBYSxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBRTdDLEtBQUssTUFBTSxPQUFPLElBQUksUUFBUSxFQUFFO1lBRTVCLE1BQU0sWUFBWSxHQUFHLGNBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLFlBQVksQ0FBQyxDQUFDO1lBRXpELElBQUk7Z0JBT0EsWUFBRSxDQUFDLFlBQVksQ0FBQyxZQUFZLENBQUMsQ0FBQztnQkFDOUIsT0FBTyxZQUFZLENBQUM7YUFFdkI7WUFBQyxPQUFPLENBQUMsRUFBRTthQUdYO1NBRUo7UUFFRCxNQUFNLElBQUksS0FBSyxDQUFDLHFCQUFxQixZQUFZLGdCQUFnQixHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztJQUVsRyxDQUFDO0lBT00sTUFBTSxDQUFDLDBCQUEwQixDQUFDLFdBQW1CLEVBQ25CLGFBQXNCLFlBQVk7UUFFdkUsSUFBSSxZQUFZLEdBQUcsV0FBVyxDQUFDO1FBQy9CLElBQUksU0FBUyxHQUFHLEVBQUUsQ0FBQztRQUVuQixJQUFJLFdBQVcsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUU7WUFDakMsWUFBWSxHQUFHLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLFdBQVcsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUNsRSxTQUFTLEdBQUcsV0FBVyxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7U0FDL0Q7UUFFRCxJQUFJLFVBQVUsRUFBRTtZQUVaLE1BQU0sWUFBWSxHQUFHLGFBQWEsQ0FBQyx3QkFBd0IsQ0FBQyxZQUFZLENBQUMsQ0FBQztZQUMxRSxPQUFPLFNBQVMsR0FBRyxZQUFZLEdBQUcsU0FBUyxDQUFDO1NBRS9DO2FBQU07WUFFSCxNQUFNLFdBQVcsR0FBRyxHQUFHLEVBQUU7Z0JBRXJCLElBQUksT0FBTyxNQUFNLEtBQUssV0FBVyxJQUFJLE1BQU0sQ0FBQyxRQUFRLEVBQUU7b0JBQ2xELE9BQU8sV0FBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO2lCQUM1QztnQkFFRCxPQUFPLHVCQUF1QixDQUFDO1lBRW5DLENBQUMsQ0FBQztZQUVGLE1BQU0sSUFBSSxHQUFHLFdBQVcsRUFBRSxDQUFDO1lBRTNCLE9BQU8sSUFBSSxHQUFHLFdBQVcsQ0FBQztTQUU3QjtJQUVMLENBQUM7SUFLUyxNQUFNLENBQUMsV0FBVztRQUV4QixNQUFNLFFBQVEsR0FBYSxFQUFFLENBQUM7UUFFOUIsSUFBSSxDQUFFLHlCQUFTLENBQUMsY0FBRyxDQUFDLEVBQUU7WUFDbEIsUUFBUSxDQUFDLElBQUksQ0FBQyxpQkFBTSxDQUFDLEdBQUcsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxDQUFDO1NBQzFDO2FBQU07WUFDSCxRQUFRLENBQUMsSUFBSSxDQUFDLGNBQUcsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxDQUFDO1NBQ25DO1FBRUQsUUFBUSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztRQUU3QixPQUFPLFFBQVEsQ0FBQztJQUVwQixDQUFDO0NBRUo7QUFqR0Qsc0NBaUdDO0FBRUQsTUFBYSxnQkFBaUIsU0FBUSxLQUFLO0NBRTFDO0FBRkQsNENBRUMiLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCB7YXBwLCByZW1vdGV9IGZyb20gJ2VsZWN0cm9uJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IGZzIGZyb20gJ2ZzJztcbmltcG9ydCB7aXNQcmVzZW50fSBmcm9tICdwb2xhci1zaGFyZWQvc3JjL1ByZWNvbmRpdGlvbnMnO1xuaW1wb3J0IHtVUkxzfSBmcm9tICdwb2xhci1zaGFyZWQvc3JjL3V0aWwvVVJMcyc7XG5cbmNvbnN0IFVTRV9GSUxFX1VSTCA9IHRydWU7XG5cbi8qKlxuICogR2l2ZW4gYSByZWxhdGl2ZSBwYXRoLCByZXR1cm4gYSBmdWxsIHBhdGggdG8gYSBsb2NhbCBhcHAgcmVzb3VyY2UuXG4gKlxuICogRWFjaCBtb2R1bGUgaGFzIGEgdW5pcXVlIF9fZGlybmFtZSBzbyB3aXRoIHRoaXMgbWVjaGFuaXNtIHdlIGNhbiByZWxpYWJseVxuICogZmluZCBhbiBwYXRoIHRvIGEgZmlsZSBhcyBpZiB3ZSB3ZXJlIGluIHRoZSByb290IG9mIHRoZSB3ZWJhcHAuXG4gKlxuICovXG5leHBvcnQgY2xhc3MgUmVzb3VyY2VQYXRocyB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBmdWxsIGFic29sdXRlIHBhdGggZnJvbSBhIHJlbGF0aXZlIHBhdGguXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBhYnNvbHV0ZUZyb21SZWxhdGl2ZVBhdGgocmVsYXRpdmVQYXRoOiBzdHJpbmcpIHtcblxuICAgICAgICAvLyBUT0RPOiBzb21ldGltZXMgYXBwUGF0aCBpcyBhbiBBU0FSIGZpbGUgYW5kIHRoYXQgcmVhbGx5IGNvbmZ1c2VzXG4gICAgICAgIC8vIHVzIGFuZCB3ZSdyZSBnb2luZyB0byBuZWVkIGEgc3RyYXRlZ3kgdG8gaGFuZGxlIHRoYXQgc2l0dWF0aW9uLlxuXG4gICAgICAgIGNvbnN0IGJhc2VEaXJzID0gUmVzb3VyY2VQYXRocy5nZXRCYXNlRGlycygpO1xuXG4gICAgICAgIGZvciAoY29uc3QgYmFzZURpciBvZiBiYXNlRGlycykge1xuXG4gICAgICAgICAgICBjb25zdCBhYnNvbHV0ZVBhdGggPSBwYXRoLnJlc29sdmUoYmFzZURpciwgcmVsYXRpdmVQYXRoKTtcblxuICAgICAgICAgICAgdHJ5IHtcblxuICAgICAgICAgICAgICAgIC8vIFdlIHVzZSByZWFkRmlsZVN5bmMgaGVyZSBiZWNhdXNlIHdlIG5lZWQgdG8gd2UgbmVlZCB0byBwZWVrXG4gICAgICAgICAgICAgICAgLy8gaW50byAuYXNhciBmaWxlcyB3aGljaCBkbyBub3Qgc3VwcG9ydCBleGlzdHMgYnV0IERPIHN1cHBvcnRcbiAgICAgICAgICAgICAgICAvLyByZWFkaW5nIHRoZSBmaWxlLiAgSWYgdGhpcyBmYWlscyB3ZSB3aWxsIGdldCBhbiBleGNlcHRpb25cbiAgICAgICAgICAgICAgICAvLyBhYm91dCBub3QgZmluZGluZyB0aGUgZmlsZS5cblxuICAgICAgICAgICAgICAgIGZzLnJlYWRGaWxlU3luYyhhYnNvbHV0ZVBhdGgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhYnNvbHV0ZVBhdGg7XG5cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBrbm93IHRoaXMgaGFwcGVucyBiZWNhdXNlIEkgY2FuJ3QgdGVzdHMgZm9yIGZpbGUgZXhpc3RzXG4gICAgICAgICAgICAgICAgLy8gc2luY2UgLmFzYXIgZmlsZXMgaGF2ZSB0byBiZSByZWFkIHRvIGNoZWNrIGZvciBleGlzdGVuY2UuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gZmlsZSBmb3VuZCBmb3IgJHtyZWxhdGl2ZVBhdGh9IGluIGJhc2VEaXJzOiBgICsgSlNPTi5zdHJpbmdpZnkoYmFzZURpcnMpKTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJ1aWxkIGEgZnVsbCByZXNvdXJjZSBVUkwgZnJvbSBhIGdpdmVuIHJlbGF0aXZlIFVSTCBwYXRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlbGF0aXZlVVJMXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyByZXNvdXJjZVVSTEZyb21SZWxhdGl2ZVVSTChyZWxhdGl2ZVVSTDogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlRmlsZVVSTDogYm9vbGVhbiA9IFVTRV9GSUxFX1VSTCk6IHN0cmluZyB7XG5cbiAgICAgICAgbGV0IHJlbGF0aXZlUGF0aCA9IHJlbGF0aXZlVVJMO1xuICAgICAgICBsZXQgcXVlcnlEYXRhID0gXCJcIjtcblxuICAgICAgICBpZiAocmVsYXRpdmVVUkwuaW5kZXhPZihcIj9cIikgIT09IC0xKSB7XG4gICAgICAgICAgICByZWxhdGl2ZVBhdGggPSByZWxhdGl2ZVVSTC5zdWJzdHJpbmcoMCwgcmVsYXRpdmVVUkwuaW5kZXhPZihcIj9cIikpO1xuICAgICAgICAgICAgcXVlcnlEYXRhID0gcmVsYXRpdmVVUkwuc3Vic3RyaW5nKHJlbGF0aXZlVVJMLmluZGV4T2YoXCI/XCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1c2VGaWxlVVJMKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGFic29sdXRlUGF0aCA9IFJlc291cmNlUGF0aHMuYWJzb2x1dGVGcm9tUmVsYXRpdmVQYXRoKHJlbGF0aXZlUGF0aCk7XG4gICAgICAgICAgICByZXR1cm4gJ2ZpbGU6Ly8nICsgYWJzb2x1dGVQYXRoICsgcXVlcnlEYXRhO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGNvbXB1dGVCYXNlID0gKCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5sb2NhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVVJMcy50b0Jhc2Uod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBcImh0dHA6Ly9sb2NhbGhvc3Q6ODUwMFwiO1xuXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjb25zdCBiYXNlID0gY29tcHV0ZUJhc2UoKTtcblxuICAgICAgICAgICAgcmV0dXJuIGJhc2UgKyByZWxhdGl2ZVVSTDtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJhc2VkaXIgb2YgdGhlIGN1cnJlbnQgd2ViYXBwLlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBzdGF0aWMgZ2V0QmFzZURpcnMoKTogc3RyaW5nW10ge1xuXG4gICAgICAgIGNvbnN0IGJhc2VEaXJzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgICAgIGlmICghIGlzUHJlc2VudChhcHApKSB7XG4gICAgICAgICAgICBiYXNlRGlycy5wdXNoKHJlbW90ZS5hcHAuZ2V0QXBwUGF0aCgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJhc2VEaXJzLnB1c2goYXBwLmdldEFwcFBhdGgoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBiYXNlRGlycy5wdXNoKHByb2Nlc3MuY3dkKCkpO1xuXG4gICAgICAgIHJldHVybiBiYXNlRGlycztcblxuICAgIH1cblxufVxuXG5leHBvcnQgY2xhc3MgQXBwUGF0aEV4Y2VwdGlvbiBleHRlbmRzIEVycm9yIHtcblxufVxuIl19