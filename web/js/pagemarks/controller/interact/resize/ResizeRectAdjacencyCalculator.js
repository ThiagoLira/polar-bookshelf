"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Rect_1 = require("../../../../Rect");
const Preconditions_1 = require("polar-shared/src/Preconditions");
const Rects_1 = require("../../../../Rects");
const Objects_1 = require("polar-shared/src/util/Objects");
class ResizeRectAdjacencyCalculator {
    calculate(resizeRect, intersectedRect, rectEdges) {
        Preconditions_1.Preconditions.assertPresent(rectEdges, "rectEdges");
        const intersectionRect = Rects_1.Rects.intersection(resizeRect, intersectedRect);
        let resizeLines = [];
        if (rectEdges.left || rectEdges.right) {
            resizeLines.push(resizeRect.toLine("x"));
        }
        if (rectEdges.top || rectEdges.bottom) {
            resizeLines.push(resizeRect.toLine("y"));
        }
        resizeLines = resizeLines.sort((a, b) => a.length - b.length);
        const resizeLine = resizeLines[0];
        if (resizeLine.axis === "x") {
            return this.__adjustLine(intersectionRect.toLine("x"), resizeRect.toLine("x"), rectEdges.toLineEdges("x"), resizeRect);
        }
        else if (resizeLine.axis === "y") {
            return this.__adjustLine(intersectionRect.toLine("y"), resizeRect.toLine("y"), rectEdges.toLineEdges("y"), resizeRect);
        }
        else {
            throw new Error("Wrong axis: " + resizeLine.axis);
        }
    }
    __adjustLine(intersectionLine, resizeLine, lineEdges, resizeRect) {
        const adjustedRect = new Rect_1.Rect(resizeRect);
        const adjustedLine = Objects_1.Objects.duplicate(resizeLine);
        if (lineEdges.start) {
            adjustedLine.start = intersectionLine.end;
        }
        else {
            adjustedLine.end = intersectionLine.start;
        }
        return adjustedRect.adjustAxis(adjustedLine);
    }
}
exports.ResizeRectAdjacencyCalculator = ResizeRectAdjacencyCalculator;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmVzaXplUmVjdEFkamFjZW5jeUNhbGN1bGF0b3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJSZXNpemVSZWN0QWRqYWNlbmN5Q2FsY3VsYXRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLDJDQUFzQztBQUl0QyxrRUFBNkQ7QUFDN0QsNkNBQXdDO0FBQ3hDLDJEQUFzRDtBQUV0RCxNQUFhLDZCQUE2QjtJQVkvQixTQUFTLENBQUMsVUFBZ0IsRUFBRSxlQUFxQixFQUFFLFNBQW9CO1FBRTFFLDZCQUFhLENBQUMsYUFBYSxDQUFDLFNBQVMsRUFBRSxXQUFXLENBQUMsQ0FBQztRQU9wRCxNQUFNLGdCQUFnQixHQUFHLGFBQUssQ0FBQyxZQUFZLENBQUMsVUFBVSxFQUFFLGVBQWUsQ0FBQyxDQUFDO1FBT3pFLElBQUksV0FBVyxHQUFHLEVBQUUsQ0FBQztRQUVyQixJQUFJLFNBQVMsQ0FBQyxJQUFJLElBQUksU0FBUyxDQUFDLEtBQUssRUFBRTtZQUNuQyxXQUFXLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztTQUM1QztRQUVELElBQUksU0FBUyxDQUFDLEdBQUcsSUFBSSxTQUFTLENBQUMsTUFBTSxFQUFFO1lBQ25DLFdBQVcsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1NBQzVDO1FBS0QsV0FBVyxHQUFHLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQVE5RCxNQUFNLFVBQVUsR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFLbEMsSUFBSSxVQUFVLENBQUMsSUFBSSxLQUFLLEdBQUcsRUFBRTtZQUV6QixPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEVBQUUsU0FBUyxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsRUFBRSxVQUFVLENBQUMsQ0FBQztTQUMxSDthQUFNLElBQUksVUFBVSxDQUFDLElBQUksS0FBSyxHQUFHLEVBQUU7WUFFaEMsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsRUFBRSxVQUFVLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLEVBQUUsVUFBVSxDQUFDLENBQUM7U0FDMUg7YUFBTTtZQUNILE1BQU0sSUFBSSxLQUFLLENBQUMsY0FBYyxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUNyRDtJQUVMLENBQUM7SUFLTyxZQUFZLENBQUMsZ0JBQXNCLEVBQUUsVUFBZ0IsRUFBRSxTQUFvQixFQUFFLFVBQWdCO1FBR2pHLE1BQU0sWUFBWSxHQUFHLElBQUksV0FBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBRTFDLE1BQU0sWUFBWSxHQUFHLGlCQUFPLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBRW5ELElBQUksU0FBUyxDQUFDLEtBQUssRUFBRTtZQUNqQixZQUFZLENBQUMsS0FBSyxHQUFHLGdCQUFnQixDQUFDLEdBQUcsQ0FBQztTQUM3QzthQUFNO1lBQ0gsWUFBWSxDQUFDLEdBQUcsR0FBRyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUM7U0FDN0M7UUFLRCxPQUFPLFlBQVksQ0FBQyxVQUFVLENBQUMsWUFBWSxDQUFDLENBQUM7SUFFakQsQ0FBQztDQUVKO0FBekZELHNFQXlGQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7UmVjdH0gZnJvbSAnLi4vLi4vLi4vLi4vUmVjdCc7XG5pbXBvcnQge0xpbmV9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWwvTGluZSc7XG5pbXBvcnQge0xpbmVFZGdlc30gZnJvbSAnLi4vZWRnZXMvTGluZUVkZ2VzJztcbmltcG9ydCB7UmVjdEVkZ2VzfSBmcm9tICcuLi9lZGdlcy9SZWN0RWRnZXMnO1xuaW1wb3J0IHtQcmVjb25kaXRpb25zfSBmcm9tICdwb2xhci1zaGFyZWQvc3JjL1ByZWNvbmRpdGlvbnMnO1xuaW1wb3J0IHtSZWN0c30gZnJvbSAnLi4vLi4vLi4vLi4vUmVjdHMnO1xuaW1wb3J0IHtPYmplY3RzfSBmcm9tIFwicG9sYXItc2hhcmVkL3NyYy91dGlsL09iamVjdHNcIjtcblxuZXhwb3J0IGNsYXNzIFJlc2l6ZVJlY3RBZGphY2VuY3lDYWxjdWxhdG9yIHtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlc2l6ZVJlY3Qge1JlY3R9IFRoZSBSZWN0IHRoYXQgdGhlIHVzZXIgaXMgcmVzaXppbmcgYW5kIGhhc24ndFxuICAgICAqIGJlZW4gYWNjZXB0ZWQgeWV0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGludGVyc2VjdGVkUmVjdCB7UmVjdH0gVGhlIHJlY3Qgd2UndmUgaW50ZXJzZWN0ZWQgd2l0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZWN0RWRnZXMge1JlY3RFZGdlc30gVGhlIHJlY3RFZGdlcyB0aGF0IGFyZSBiZWluZyByZXNpemVkLlxuICAgICAqXG4gICAgICovXG4gICAgcHVibGljIGNhbGN1bGF0ZShyZXNpemVSZWN0OiBSZWN0LCBpbnRlcnNlY3RlZFJlY3Q6IFJlY3QsIHJlY3RFZGdlczogUmVjdEVkZ2VzKSB7XG5cbiAgICAgICAgUHJlY29uZGl0aW9ucy5hc3NlcnRQcmVzZW50KHJlY3RFZGdlcywgXCJyZWN0RWRnZXNcIik7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJERUJVRyBSZXNpemVSZWN0QWRqYWNlbmN5Q2FsY3VsYXRvci5jYWxjdWxhdGU6IHJlc2l6ZVJlY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkocmVzaXplUmVjdCwgbnVsbCwgXCIgIFwiKSk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiREVCVUcgUmVzaXplUmVjdEFkamFjZW5jeUNhbGN1bGF0b3IuY2FsY3VsYXRlOiBpbnRlcnNlY3RlZFJlY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkoaW50ZXJzZWN0ZWRSZWN0LCBudWxsLCBcIiAgXCIpKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJERUJVRyBSZXNpemVSZWN0QWRqYWNlbmN5Q2FsY3VsYXRvci5jYWxjdWxhdGU6IHJlY3RFZGdlczogXCIgKyBKU09OLnN0cmluZ2lmeShyZWN0RWRnZXMsIG51bGwsIFwiICBcIikpO1xuXG4gICAgICAgIC8vIGNvbXB1dGUgdGhlIGludGVyc2VjdGlvbiBvZiB0aGUgdHdvIHJlY3RzLlxuICAgICAgICBjb25zdCBpbnRlcnNlY3Rpb25SZWN0ID0gUmVjdHMuaW50ZXJzZWN0aW9uKHJlc2l6ZVJlY3QsIGludGVyc2VjdGVkUmVjdCk7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJERUJVRzogaW50ZXJzZWN0aW9uUmVjdDogXCIgKyBKU09OLnN0cmluZ2lmeShpbnRlcnNlY3Rpb25SZWN0LCBudWxsLCBcIiAgXCIpKTtcblxuICAgICAgICAvLyBUT0RPOiB3ZSBjYW4gcmVmYWN0b3IgdGhpcyB0byBwYXNzIF9fYWRqdXN0TGluZSB0aGUgYXhpcyBhbmQgdGhlbiBjYWxsXG4gICAgICAgIC8vIHRvTGluZShheGlzKSBvbiBlYWNoIHJlY3QgaW5zaWRlIF9hZGp1c3RSZWN0LlxuXG4gICAgICAgIGxldCByZXNpemVMaW5lcyA9IFtdO1xuXG4gICAgICAgIGlmIChyZWN0RWRnZXMubGVmdCB8fCByZWN0RWRnZXMucmlnaHQpIHtcbiAgICAgICAgICAgIHJlc2l6ZUxpbmVzLnB1c2gocmVzaXplUmVjdC50b0xpbmUoXCJ4XCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWN0RWRnZXMudG9wIHx8IHJlY3RFZGdlcy5ib3R0b20pIHtcbiAgICAgICAgICAgIHJlc2l6ZUxpbmVzLnB1c2gocmVzaXplUmVjdC50b0xpbmUoXCJ5XCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vdyBzb3J0IHRoZSBsaW5lcyBieSB0aGVpciBsZW5ndGggdG8gc2VlIHdoaWNoIG9uZSB3ZSBzaG91bGQgdXNlLlxuICAgICAgICAvLyBXZSBzaG91bGQgcGljayB0aGUgbG9uZ2VzdCBsaW5lIGFuZCBhZGp1c3QgYnkgdGhhdC5cblxuICAgICAgICByZXNpemVMaW5lcyA9IHJlc2l6ZUxpbmVzLnNvcnQoKGEsIGIpID0+IGEubGVuZ3RoIC0gYi5sZW5ndGgpO1xuXG4gICAgICAgIC8vIHRoZXkgc2hvdWxkIGJlIGRlc2NlbmRpbmcuICBJIGNvdWxkIGNoYW5nZSB0aGUgc29ydCBhbGdvcml0aG0gYnV0XG4gICAgICAgIC8vIEkgdGhpbmsgdGhlIGNvZGUgaXMgbW9yZSBjbGVhciB0aGF0IHdlIHdhbnQgZGVzY2VuZGluZyB0aGlzIHdheS5cbiAgICAgICAgLy8gcmVzaXplTGluZXMgPSByZXNpemVMaW5lcy5yZXZlcnNlKCk7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJERUJVRzogcmVzaXplTGluZXM6IFwiICsgSlNPTi5zdHJpbmdpZnkocmVzaXplTGluZXMsIG51bGwsIFwiICBcIikpO1xuXG4gICAgICAgIGNvbnN0IHJlc2l6ZUxpbmUgPSByZXNpemVMaW5lc1swXTtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIkRFQlVHOiByZXNpemVMaW5lOiBcIiArIEpTT04uc3RyaW5naWZ5KHJlc2l6ZUxpbmUsIG51bGwsIFwiICBcIikpO1xuXG4gICAgICAgIC8vIHJlc2l6ZSBiYXNlZCBvbiB0aGUgbGFyZ2VyIGF4aXMgbm93LlxuICAgICAgICBpZiAocmVzaXplTGluZS5heGlzID09PSBcInhcIikge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJSZXNpemluZyBYIGF4aXNcIik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fX2FkanVzdExpbmUoaW50ZXJzZWN0aW9uUmVjdC50b0xpbmUoXCJ4XCIpLCByZXNpemVSZWN0LnRvTGluZShcInhcIiksIHJlY3RFZGdlcy50b0xpbmVFZGdlcyhcInhcIiksIHJlc2l6ZVJlY3QpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc2l6ZUxpbmUuYXhpcyA9PT0gXCJ5XCIpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiUmVzaXppbmcgWSBheGlzXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19hZGp1c3RMaW5lKGludGVyc2VjdGlvblJlY3QudG9MaW5lKFwieVwiKSwgcmVzaXplUmVjdC50b0xpbmUoXCJ5XCIpLCByZWN0RWRnZXMudG9MaW5lRWRnZXMoXCJ5XCIpLCByZXNpemVSZWN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldyb25nIGF4aXM6IFwiICsgcmVzaXplTGluZS5heGlzKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIF9fYWRqdXN0TGluZShpbnRlcnNlY3Rpb25MaW5lOiBMaW5lLCByZXNpemVMaW5lOiBMaW5lLCBsaW5lRWRnZXM6IExpbmVFZGdlcywgcmVzaXplUmVjdDogUmVjdCkge1xuXG4gICAgICAgIC8vIHRoZSByZWN0IHRoYXQgd2UgYXJlIGdvaW5nIHRvIGFkanVzdCBhbmQgdGhlbiB1c2UgaW4gdGhlIFVJLlxuICAgICAgICBjb25zdCBhZGp1c3RlZFJlY3QgPSBuZXcgUmVjdChyZXNpemVSZWN0KTtcblxuICAgICAgICBjb25zdCBhZGp1c3RlZExpbmUgPSBPYmplY3RzLmR1cGxpY2F0ZShyZXNpemVMaW5lKTtcblxuICAgICAgICBpZiAobGluZUVkZ2VzLnN0YXJ0KSB7XG4gICAgICAgICAgICBhZGp1c3RlZExpbmUuc3RhcnQgPSBpbnRlcnNlY3Rpb25MaW5lLmVuZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFkanVzdGVkTGluZS5lbmQgPSBpbnRlcnNlY3Rpb25MaW5lLnN0YXJ0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGVjaG5pY2FsbHkgd2UgaGF2ZSB0byBhZGp1c3QgdGhlIHdpZHRoIG9mIHRoZSBsaW5lIGJ1dCB0aGUgd2lkdGhcbiAgICAgICAgLy8gYWNjZXNzb3Igb24gTGluZSBjb21wdXRlcyBpdCBmb3IgdXMuXG5cbiAgICAgICAgcmV0dXJuIGFkanVzdGVkUmVjdC5hZGp1c3RBeGlzKGFkanVzdGVkTGluZSk7XG5cbiAgICB9XG5cbn1cbiJdfQ==