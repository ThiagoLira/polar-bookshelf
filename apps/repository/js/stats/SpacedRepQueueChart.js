"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const React = __importStar(require("react"));
const StatTitle_1 = __importDefault(require("./StatTitle"));
const line_1 = require("@nivo/line");
const Statistics_1 = require("polar-shared/src/util/Statistics");
const ISODateTimeStrings_1 = require("polar-shared/src/metadata/ISODateTimeStrings");
const S2Plus_1 = require("polar-spaced-repetition-api/src/scheduler/S2Plus/S2Plus");
const ReviewerStatistics_1 = require("../reviewer/ReviewerStatistics");
const Logger_1 = require("polar-shared/src/logger/Logger");
const StatBox_1 = require("./StatBox");
const LoadingProgress_1 = require("../../../../web/js/ui/LoadingProgress");
const log = Logger_1.Logger.create();
class SpacedRepQueueChart extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            data: undefined
        };
    }
    componentDidMount() {
        ReviewerStatistics_1.ReviewerStatistics.statistics(this.props.mode, this.props.type)
            .then(data => this.setState({ data }))
            .catch(err => log.error("Could not fetch queue stats: ", err));
    }
    render() {
        const { data } = this.state;
        if (!data) {
            return React.createElement(LoadingProgress_1.LoadingProgress, null);
        }
        const computeStats = () => {
            const firstDatapointsReducer = (timestamp, datapoints) => {
                const first = datapoints[0];
                return Object.assign(Object.assign({}, first), { created: timestamp });
            };
            const minDatapointsReducer = (timestamp, datapoints) => {
                const min = S2Plus_1.StageCountsCalculator.createMutable();
                datapoints.forEach(current => {
                    min.nrNew = Math.min(min.nrNew, current.nrNew);
                    min.nrLapsed = Math.min(min.nrLapsed, current.nrLapsed);
                    min.nrLearning = Math.min(min.nrLearning, current.nrLearning);
                    min.nrReview = Math.min(min.nrReview, current.nrReview);
                });
                const first = datapoints[0];
                return Object.assign(Object.assign({}, first), { created: timestamp });
            };
            const sumDatapointsReducer = (timestamp, datapoints) => {
                const sum = S2Plus_1.StageCountsCalculator.createMutable();
                datapoints.forEach(current => {
                    sum.nrNew += current.nrNew;
                    sum.nrLapsed += current.nrLapsed;
                    sum.nrLearning += current.nrLearning;
                    sum.nrReview += current.nrReview;
                });
                const first = datapoints[0];
                return Object.assign(Object.assign(Object.assign({}, first), sum), { created: timestamp });
            };
            const createDatapointsReducer = () => {
                switch (this.props.type) {
                    case "queue":
                        return minDatapointsReducer;
                    case "completed":
                        return sumDatapointsReducer;
                }
            };
            return Statistics_1.Statistics.compute(data, createDatapointsReducer());
        };
        const stats = computeStats();
        const computeLineData = () => {
            const toDataPoint = (spacedRepStat, id) => {
                const x = ISODateTimeStrings_1.ISODateTimeStrings.parse(spacedRepStat.created);
                const y = spacedRepStat[id];
                return { x, y };
            };
            const computeLine = (id) => {
                return {
                    id,
                    data: stats.map(current => toDataPoint(current, id))
                };
            };
            return [
                computeLine('nrLearning'),
                computeLine('nrReview'),
                computeLine('nrLapsed')
            ];
        };
        const lineData = computeLineData();
        const NeedChardData = () => {
            return React.createElement("div", null);
        };
        const Chart = () => {
            const createTitle = () => {
                switch (this.props.type) {
                    case "queue":
                        return "Number of tasks pending (queue length)";
                    case "completed":
                        return "Number of tasks completed";
                }
            };
            const title = createTitle();
            return (React.createElement("div", { className: "" },
                React.createElement(StatBox_1.StatBox, { style: { height: '300px', width: '100%' } },
                    React.createElement(StatTitle_1.default, null, title),
                    React.createElement(line_1.ResponsiveLine, { data: lineData, margin: {
                            top: 10,
                            right: 10,
                            bottom: 50,
                            left: 40
                        }, colors: "set1", colorBy: "id", enableArea: true, yScale: {
                            type: 'linear'
                        }, xScale: {
                            type: 'time',
                        }, axisBottom: {
                            format: '%b %d',
                            tickValues: 5,
                        }, animate: true }))));
        };
        const Main = () => {
            if (lineData[0].data.length < 3) {
                return React.createElement(NeedChardData, null);
            }
            else {
                return React.createElement(Chart, null);
            }
        };
        return React.createElement("div", { className: "", style: {} },
            React.createElement(Main, null));
    }
}
exports.SpacedRepQueueChart = SpacedRepQueueChart;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3BhY2VkUmVwUXVldWVDaGFydC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIlNwYWNlZFJlcFF1ZXVlQ2hhcnQudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLDZDQUErQjtBQUMvQiw0REFBb0M7QUFDcEMscUNBQW9FO0FBRXBFLGlFQUE0RDtBQUM1RCxxRkFBbUc7QUFDbkcsb0ZBQThHO0FBQzlHLHVFQUFrRTtBQUNsRSwyREFBc0Q7QUFDdEQsdUNBQWtDO0FBQ2xDLDJFQUFzRTtBQUV0RSxNQUFNLEdBQUcsR0FBRyxlQUFNLENBQUMsTUFBTSxFQUFFLENBQUM7QUFFNUIsTUFBYSxtQkFBb0IsU0FBUSxLQUFLLENBQUMsU0FBeUI7SUFFcEUsWUFBWSxLQUF1QjtRQUMvQixLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFYixJQUFJLENBQUMsS0FBSyxHQUFHO1lBQ1QsSUFBSSxFQUFFLFNBQVM7U0FDbEIsQ0FBQztJQUNOLENBQUM7SUFFTSxpQkFBaUI7UUFFcEIsdUNBQWtCLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDO2FBQzFELElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsRUFBQyxJQUFJLEVBQUMsQ0FBQyxDQUFDO2FBQ25DLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsK0JBQStCLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUV2RSxDQUFDO0lBRU0sTUFBTTtRQUVULE1BQU0sRUFBQyxJQUFJLEVBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO1FBRTFCLElBQUksQ0FBRSxJQUFJLEVBQUU7WUFDUixPQUFPLG9CQUFDLGlDQUFlLE9BQUUsQ0FBQztTQUM3QjtRQU1ELE1BQU0sWUFBWSxHQUFHLEdBQUcsRUFBRTtZQU10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QUFFLEVBQUU7NEJBQ1QsTUFBTSxFQUFFLEVBQUU7NEJBQ1YsSUFBSSxFQUFFLEVBQUU7eUJBQ1gsRUFFRCxNQUFNLEVBQUMsTUFBTSxFQUNiLE9BQU8sRUFBQyxJQUFJLEVBQ1osVUFBVSxFQUFFLElBQUksRUFDaEIsTUFBTSxFQUFFOzRCQUNKLElBQUksRUFBRSxRQUFRO3lCQUNqQixFQUNELE1BQU0sRUFBRTs0QkFDSixJQUFJLEVBQUUsTUFBTTt5QkFJZixFQUVELFVBQVUsRUFBRTs0QkFDUixNQUFNLEVBQUUsT0FBTzs0QkFFZixVQUFVLEVBQUUsQ0FBQzt5QkFHaEIsRUFHRCxPQUFPLEVBQUUsSUFBSSxHQUVmLENBQ0ksQ0FDUixDQUVULENBQUM7UUFFTixDQUFDLENBQUM7UUFFRixNQUFNLElBQUksR0FBRyxHQUFHLEVBQUU7WUFFZCxJQUFJLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtnQkFDN0IsT0FBTyxvQkFBQyxhQUFhLE9BQUUsQ0FBQzthQUMzQjtpQkFBTTtnQkFDSCxPQUFPLG9CQUFDLEtBQUssT0FBRSxDQUFDO2FBQ25CO1FBRUwsQ0FBQyxDQUFDO1FBRUYsT0FBTyw2QkFBSyxTQUFTLEVBQUMsRUFBRSxFQUNaLEtBQUssRUFBRSxFQUFFO1lBRWpCLG9CQUFDLElBQUksT0FBRSxDQUVMLENBQUM7SUFFWCxDQUFDO0NBRUo7QUFoUEQsa0RBZ1BDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFN0YXRUaXRsZSBmcm9tICcuL1N0YXRUaXRsZSc7XG5pbXBvcnQge0xpbmVEYXR1bSwgTGluZVNlcmllRGF0YSwgUmVzcG9uc2l2ZUxpbmV9IGZyb20gJ0BuaXZvL2xpbmUnO1xuaW1wb3J0IHtTcGFjZWRSZXBTdGF0UmVjb3JkLCBTdGF0VHlwZX0gZnJvbSBcInBvbGFyLWZpcmViYXNlL3NyYy9maXJlYmFzZS9vbS9TcGFjZWRSZXBTdGF0c1wiO1xuaW1wb3J0IHtTdGF0aXN0aWNzfSBmcm9tIFwicG9sYXItc2hhcmVkL3NyYy91dGlsL1N0YXRpc3RpY3NcIjtcbmltcG9ydCB7SVNPRGF0ZVRpbWVTdHJpbmcsIElTT0RhdGVUaW1lU3RyaW5nc30gZnJvbSBcInBvbGFyLXNoYXJlZC9zcmMvbWV0YWRhdGEvSVNPRGF0ZVRpbWVTdHJpbmdzXCI7XG5pbXBvcnQge1JlcGV0aXRpb25Nb2RlLCBTdGFnZUNvdW50c0NhbGN1bGF0b3J9IGZyb20gXCJwb2xhci1zcGFjZWQtcmVwZXRpdGlvbi1hcGkvc3JjL3NjaGVkdWxlci9TMlBsdXMvUzJQbHVzXCI7XG5pbXBvcnQge1Jldmlld2VyU3RhdGlzdGljc30gZnJvbSBcIi4uL3Jldmlld2VyL1Jldmlld2VyU3RhdGlzdGljc1wiO1xuaW1wb3J0IHtMb2dnZXJ9IGZyb20gXCJwb2xhci1zaGFyZWQvc3JjL2xvZ2dlci9Mb2dnZXJcIjtcbmltcG9ydCB7U3RhdEJveH0gZnJvbSBcIi4vU3RhdEJveFwiO1xuaW1wb3J0IHtMb2FkaW5nUHJvZ3Jlc3N9IGZyb20gXCIuLi8uLi8uLi8uLi93ZWIvanMvdWkvTG9hZGluZ1Byb2dyZXNzXCI7XG5cbmNvbnN0IGxvZyA9IExvZ2dlci5jcmVhdGUoKTtcblxuZXhwb3J0IGNsYXNzIFNwYWNlZFJlcFF1ZXVlQ2hhcnQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8SVByb3BzLCBJU3RhdGU+IHtcblxuICAgIGNvbnN0cnVjdG9yKHByb3BzOiBSZWFkb25seTxJUHJvcHM+KSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgZGF0YTogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHVibGljIGNvbXBvbmVudERpZE1vdW50KCk6IHZvaWQge1xuXG4gICAgICAgIFJldmlld2VyU3RhdGlzdGljcy5zdGF0aXN0aWNzKHRoaXMucHJvcHMubW9kZSwgdGhpcy5wcm9wcy50eXBlKVxuICAgICAgICAgICAgLnRoZW4oZGF0YSA9PiB0aGlzLnNldFN0YXRlKHtkYXRhfSkpXG4gICAgICAgICAgICAuY2F0Y2goZXJyID0+IGxvZy5lcnJvcihcIkNvdWxkIG5vdCBmZXRjaCBxdWV1ZSBzdGF0czogXCIsIGVycikpO1xuXG4gICAgfVxuXG4gICAgcHVibGljIHJlbmRlcigpIHtcblxuICAgICAgICBjb25zdCB7ZGF0YX0gPSB0aGlzLnN0YXRlO1xuXG4gICAgICAgIGlmICghIGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiA8TG9hZGluZ1Byb2dyZXNzLz47XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIFRPRE86IHRoZXNlIG5lZWQgYmV0dGVyIHN0YXRzIHNlY3Rpb25zIGZvciBpbmNyZW1lbnRhbCByZWFkaW5nIGFuZCBmbGFzaGNhcmRzIGFzIHdlIHNob3VsZCBoYXZlIGNvdW50cyxcbiAgICAgICAgLy8gZm9yZWNhc3RpbmcsIGFuZCBjb21wbGV0ZWQgZm9yIGFsbC4uLlxuXG4gICAgICAgIGNvbnN0IGNvbXB1dGVTdGF0cyA9ICgpID0+IHtcblxuICAgICAgICAgICAgLy8gVE9ETzogbGltaXQgb24gdGhlIG1vc3QgcmVjZW50IE4gcG9pbnRzIHNvIHRoYXQgSSBkb24ndCBjcm93ZCB1cCB0aGUgVUkgQlVUIHRoZSBwb2ludHMgbmVlZCB0byBiZVxuICAgICAgICAgICAgLy8gZXh0cmFwb2xhdGVkIGluY2x1ZGluZyBnYXBzIGZvciB0aW1lIGJlY2F1c2UgSSBjb3VsZCBoYXZlIG9uZSBkYXRhcG9pbnQgNSB5ZWFycyBhZ28gYW5kIGFub3RoZXIgdG9kYXlcbiAgICAgICAgICAgIC8vIGFuZCB0aGUgaW50ZXJwb2xhdGVkIHBvaW50cyBzaG93biBpbiB0aGUgZ3JhcGggd291bGQgYmUgdG9vIG1hbnlcblxuICAgICAgICAgICAgY29uc3QgZmlyc3REYXRhcG9pbnRzUmVkdWNlciA9ICh0aW1lc3RhbXA6IElTT0RhdGVUaW1lU3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFwb2ludHM6IFJlYWRvbmx5QXJyYXk8U3BhY2VkUmVwU3RhdFJlY29yZD4pOiBTcGFjZWRSZXBTdGF0UmVjb3JkID0+IHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0ID0gZGF0YXBvaW50c1swXTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5maXJzdCxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlZDogdGltZXN0YW1wXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc3QgbWluRGF0YXBvaW50c1JlZHVjZXIgPSAodGltZXN0YW1wOiBJU09EYXRlVGltZVN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YXBvaW50czogUmVhZG9ubHlBcnJheTxTcGFjZWRSZXBTdGF0UmVjb3JkPik6IFNwYWNlZFJlcFN0YXRSZWNvcmQgPT4ge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbWluID0gU3RhZ2VDb3VudHNDYWxjdWxhdG9yLmNyZWF0ZU11dGFibGUoKTtcblxuXG4gICAgICAgICAgICAgICAgZGF0YXBvaW50cy5mb3JFYWNoKGN1cnJlbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBtaW4ubnJOZXcgPSBNYXRoLm1pbihtaW4ubnJOZXcsIGN1cnJlbnQubnJOZXcpO1xuICAgICAgICAgICAgICAgICAgICBtaW4ubnJMYXBzZWQgPSBNYXRoLm1pbihtaW4ubnJMYXBzZWQsIGN1cnJlbnQubnJMYXBzZWQpO1xuICAgICAgICAgICAgICAgICAgICBtaW4ubnJMZWFybmluZyA9IE1hdGgubWluKG1pbi5uckxlYXJuaW5nLCBjdXJyZW50Lm5yTGVhcm5pbmcpO1xuICAgICAgICAgICAgICAgICAgICBtaW4ubnJSZXZpZXcgPSBNYXRoLm1pbihtaW4ubnJSZXZpZXcsIGN1cnJlbnQubnJSZXZpZXcpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3QgPSBkYXRhcG9pbnRzWzBdO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmZpcnN0LFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVkOiB0aW1lc3RhbXBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjb25zdCBzdW1EYXRhcG9pbnRzUmVkdWNlciA9ICh0aW1lc3RhbXA6IElTT0RhdGVUaW1lU3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YXBvaW50czogUmVhZG9ubHlBcnJheTxTcGFjZWRSZXBTdGF0UmVjb3JkPik6IFNwYWNlZFJlcFN0YXRSZWNvcmQgPT4ge1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgc3VtID0gU3RhZ2VDb3VudHNDYWxjdWxhdG9yLmNyZWF0ZU11dGFibGUoKTtcblxuICAgICAgICAgICAgICAgIGRhdGFwb2ludHMuZm9yRWFjaChjdXJyZW50ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc3VtLm5yTmV3ICs9IGN1cnJlbnQubnJOZXc7XG4gICAgICAgICAgICAgICAgICAgIHN1bS5uckxhcHNlZCArPSBjdXJyZW50Lm5yTGFwc2VkO1xuICAgICAgICAgICAgICAgICAgICBzdW0ubnJMZWFybmluZyArPSBjdXJyZW50Lm5yTGVhcm5pbmc7XG4gICAgICAgICAgICAgICAgICAgIHN1bS5uclJldmlldyArPSBjdXJyZW50Lm5yUmV2aWV3O1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3QgPSBkYXRhcG9pbnRzWzBdO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZmlyc3QsXG4gICAgICAgICAgICAgICAgICAgIC4uLnN1bSxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlZDogdGltZXN0YW1wXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjb25zdCBjcmVhdGVEYXRhcG9pbnRzUmVkdWNlciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBzd2l0Y2godGhpcy5wcm9wcy50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJxdWV1ZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1pbkRhdGFwb2ludHNSZWR1Y2VyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY29tcGxldGVkXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VtRGF0YXBvaW50c1JlZHVjZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIFN0YXRpc3RpY3MuY29tcHV0ZShkYXRhLCBjcmVhdGVEYXRhcG9pbnRzUmVkdWNlcigpKTtcblxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHN0YXRzID0gY29tcHV0ZVN0YXRzKCk7XG5cbiAgICAgICAgY29uc3QgY29tcHV0ZUxpbmVEYXRhID0gKCkgPT4ge1xuXG4gICAgICAgICAgICB0eXBlIFN0YXRJRCA9ICduckxlYXJuaW5nJyB8ICduclJldmlldycgfCAnbnJMYXBzZWQnO1xuXG4gICAgICAgICAgICAvLyBjb25zdCBjb21wdXRlTGluZSA9IChpZDogU3RhdElEKTogTGluZVNlcmllRGF0YSA9PiB7XG4gICAgICAgICAgICAvLyAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8vICAgICAgICAgaWQsXG4gICAgICAgICAgICAvLyAgICAgICAgIGRhdGE6IFtcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgIC8vIHt4OiBuZXcgRGF0ZSgnMjAxOS0xMS0wMScpLCB5OiAxMDB9LFxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgLy8ge3g6ICcyMDE5LTExLTAxJywgeTogMTAwfSxcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgIC8vIHt4OiAnMjAxOS0xMS0wMicsIHk6IDE1MH0sXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAvLyB7eDogJzIwMTktMTEtMDMnLCB5OiAxMjB9LFxuICAgICAgICAgICAgLy8gICAgICAgICBdXG4gICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgLy8gfTtcblxuICAgICAgICAgICAgY29uc3QgdG9EYXRhUG9pbnQgPSAoc3BhY2VkUmVwU3RhdDogU3BhY2VkUmVwU3RhdFJlY29yZCwgaWQ6IFN0YXRJRCk6IExpbmVEYXR1bSA9PiB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gSVNPRGF0ZVRpbWVTdHJpbmdzLnBhcnNlKHNwYWNlZFJlcFN0YXQuY3JlYXRlZCk7XG4gICAgICAgICAgICAgICAgLy8gY29uc3QgeSA9IHNwYWNlZFJlcFN0YXQubnJMZWFybmluZztcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gKHNwYWNlZFJlcFN0YXQgYXMgYW55KVtpZF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt4LCB5fTtcblxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc3QgY29tcHV0ZUxpbmUgPSAoaWQ6IFN0YXRJRCk6IExpbmVTZXJpZURhdGEgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBzdGF0cy5tYXAoY3VycmVudCA9PiB0b0RhdGFQb2ludChjdXJyZW50LCBpZCkpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBjb21wdXRlTGluZSgnbnJMZWFybmluZycpLFxuICAgICAgICAgICAgICAgIGNvbXB1dGVMaW5lKCduclJldmlldycpLFxuICAgICAgICAgICAgICAgIGNvbXB1dGVMaW5lKCduckxhcHNlZCcpXG4gICAgICAgICAgICBdO1xuXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgbGluZURhdGE6IExpbmVTZXJpZURhdGFbXSA9IGNvbXB1dGVMaW5lRGF0YSgpO1xuXG4gICAgICAgIGNvbnN0IE5lZWRDaGFyZERhdGEgPSAoKSA9PiB7XG4gICAgICAgICAgICAvLyByZXR1cm4gPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LWxnIHRleHQtbXV0ZWQgbXQtMlwiXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJ1xuICAgICAgICAgICAgLy8gICAgICAgICAgICAgfX0+XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gICAgIDxkaXYgY2xhc3NOYW1lPVwibS1hdXRvXCI+XG4gICAgICAgICAgICAvLyAgICAgICAgIE1vcmUgZGF0YSBuZWVkZWQgZm9yIHJlbGlhYmxlIGNoYXJ0LlxuICAgICAgICAgICAgLy8gICAgIDwvZGl2PlxuICAgICAgICAgICAgLy8gPC9kaXY+O1xuXG4gICAgICAgICAgICByZXR1cm4gPGRpdi8+O1xuXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgQ2hhcnQgPSAoKSA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZVRpdGxlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHN3aXRjaCh0aGlzLnByb3BzLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInF1ZXVlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJOdW1iZXIgb2YgdGFza3MgcGVuZGluZyAocXVldWUgbGVuZ3RoKVwiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY29tcGxldGVkXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJOdW1iZXIgb2YgdGFza3MgY29tcGxldGVkXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc3QgdGl0bGUgPSBjcmVhdGVUaXRsZSgpO1xuXG4gICAgICAgICAgICByZXR1cm4gKFxuXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJcIj5cbiAgICAgICAgICAgICAgICAgICAgPFN0YXRCb3ggc3R5bGU9e3toZWlnaHQ6ICczMDBweCcsIHdpZHRoOiAnMTAwJSd9fT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxTdGF0VGl0bGU+e3RpdGxlfTwvU3RhdFRpdGxlPlxuXG4gICAgICAgICAgICAgICAgICAgICAgICA8UmVzcG9uc2l2ZUxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhPXtsaW5lRGF0YX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW49e3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiAxMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IDEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3R0b206IDUwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiA0MFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGFkZGluZz17MC4zfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9ycz1cInNldDFcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yQnk9XCJpZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlQXJlYT17dHJ1ZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5U2NhbGU9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2xpbmVhcidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhTY2FsZT17e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndGltZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvcm1hdDogJyVZLSVtLSVkVCVoOiVtOiVzLiVtc1onLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3JtYXQ6ICclWS0lbS0lZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByZWNpc2lvbjogJ2RheScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB4Rm9ybWF0PVwidGltZTolWS0lbS0lZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXhpc0JvdHRvbT17e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6ICclYiAlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRpY2tWYWx1ZXM6IFsnZXZlcnkgMiBkYXlzJywgJ2V2ZXJ5IDIgZGF5cycsICdldmVyeSAyIGRheXMnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlja1ZhbHVlczogNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGVnZW5kOiAndGltZSBzY2FsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxlZ2VuZE9mZnNldDogLTEyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlTWVzaD17dHJ1ZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbmFibGVQb2ludExhYmVsPXt0cnVlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGU9e3RydWV9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgIDwvU3RhdEJveD5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgKTtcblxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IE1haW4gPSAoKSA9PiB7XG5cbiAgICAgICAgICAgIGlmIChsaW5lRGF0YVswXS5kYXRhLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gPE5lZWRDaGFyZERhdGEvPjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDxDaGFydC8+O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIDxkaXYgY2xhc3NOYW1lPVwiXCJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3t9fT5cblxuICAgICAgICAgICAgPE1haW4vPlxuXG4gICAgICAgIDwvZGl2PjtcblxuICAgIH1cblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIElQcm9wcyB7XG4gICAgcmVhZG9ubHkgbW9kZTogUmVwZXRpdGlvbk1vZGU7XG4gICAgcmVhZG9ubHkgdHlwZTogU3RhdFR5cGU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVN0YXRlIHtcbiAgICByZWFkb25seSBkYXRhOiBSZWFkb25seUFycmF5PFNwYWNlZFJlcFN0YXRSZWNvcmQ+IHwgdW5kZWZpbmVkO1xufVxuXG5cbiJdfQ==